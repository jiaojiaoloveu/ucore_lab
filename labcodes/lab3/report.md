#lab2 实验报告
----

#练习1：给未被映射的地址映射上物理页（需要编程）

#实现方式：
>首先调用get_pte函数，利用mm中的pgdir和addr得到ptep。如果该物理地址不存在页表中的话，就调用pgdir_alloc_page新建一个物理页，并映射虚拟地址给它。

#与参考答案差异
>实现步骤相同。


#请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
>也目录项和页表中的标志位，记录了页是否被修改，页是否有读写权限等信息。在页替换算法过程中，需要根据这些标志位来判断替换的顺序等策略。

#如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
>硬件需要在发生异常时保存EPC等寄存器的值,供之后返回时使用。跳转到异常处理程序，等异常处理程序运行结束后恢复现场。


#练习2：补充完成基于FIFO的页面替换算法（需要编程）
#实现方式
>在vmm.c中，首先判断页置换初始化是否已经完成，如果swap_init_ok==1则进行页置换的过程，新建一个page，调用swap_in函数得到对应页的内容。然后调用page_insert函数，将这一页的物理地址与逻辑地址映射起来。最后调用swap_map_swappable使用fifo页替换策略，将这个新产生的页换入其中。  
>在swap_fifo中实现了fifo_map_swappable函数，主要作业是将最近使用的页面放入队列的头部。即调用list_add完成这个操作。同时还实现了fifo_swap_out_victim，即将队列中最早访问的元素踢出队列。由于是循环链表储存，队尾元素即为head->prev将这个元素del，然后将ptr_page的地址设置为这一项的地址。

#与参考答案差异
>参考答案在实现过程中判断了队列为空的情况、页为空的情况等发生错误的情况，使用assert或者输出进行了提示。实现的更为细致。

#如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题
#需要被换出的页的特征是什么？
>被换出的页使用位和修改位都为0，且被当前的指针指到。

#在ucore中如何判断具有这样特征的页？
>维护一个双向链表，每个链表项中除了储存关于页的信息，再额外储存两位作为使用位和修改位。在进行clock算法时候，扫过循环列表，根据使用位和修改位来判断这些页。

#何时进行换入和换出操作？
>当需要读写一个页面，且页面不在内存中时需要换入这个页面。当需要换入页面时，页面总数已经满了则需要转动指针找到修改位和使用位都为0的页面进行换出操作。

#本次实验中重要的知识点：
>给未被映射的地址映射物理页的方式
>页表的替换的策略
>各种不同替换策略的差异与优劣
>以上知识点对应了原理课中所描述的，页替换策略的知识点。

#未涉及到的知识点：  
>原理课中还介绍了belady现象，工作集置换算法，缺页率置换算法，抖动与负载等知识点。

