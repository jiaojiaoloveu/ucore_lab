# Lab5 report

## [练习1] 加载应用程序并执行

# 设计实现过程
```
设置trapframe的CS，DS，ES，SS段为用户段
设置esp为用户栈顶地址
设置eip为ELF入口位置
设置tf_eflags为FL_IF，允许中断
```

# 请描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。
```
init_main通过do_fork、do_execv创建用户新进程
创建的新进程被插入队列等待执行，通过schedule的选择新的进程获准执行
```

## [练习2] 父进程复制自己的内存空间给子进程

# 请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。
```
父进程创建子进程时不复制共享地址空间，直接共享，可以设置成只读模式避免发生误写
当其中一方发生写操作时，将共享空间进行复制，父子各得到一份，之后双方在各自空间内进行自由读写
```

## [练习3] 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

# 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？
```
fork：产生当前进程的子进程
exec：将新的二进制代码加载进当前进程
wait：等待当前进程的子进程执行
exit：退出当前进程
```

# 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，
以及产生变换的事件或函数调用）。（字符方式画即可）
```
PROC_UNINIT -> exec -> PROC_RUNNABLE -> run -> (father)fork -> wait sons -> exit 
(son)fork -> run -> over -> PROC_ZOMBIE
```

## [与参考答案的区别]
```
思路差不多，代码实现上略有不同。
```

## [实验中重要的知识点]
```
用户进程创建
系统调用框架的实现机制
ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理
```

