# Lab7 report

## [练习1]
理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

1-1 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。
```
内核级信号量即是semaphor_t，相关操作有sema_init，up，down，try_down
sema_init:初始化函数，设定一个某初始值的信号量
up:查找是否存在进程处于等待状态，如果有则唤醒一个，否则信号量的值增加1
   在up函数中存在local_intr_save……local_intr_store，这说明这段过程是不能被中断的，也就是保证了这段程序的原子性
down:查看信号量的值是否为正数，如果是则减1，否则进入等待队列并进行一次调度，和up操作一样，这个操作是原子的
try_down:只检查信号量的值是否为正数，如果是则减1，这个操作也是原子的
```

1-2 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
```
用户态没有办法关闭中断，可以使用系统调用的方法来使用户态进程可以使用信号量机制，
也可以使用一些指令系统中的原子操作设计面向用户态进程的信号量机制
```

## [练习2]
完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

2-1 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。
```
内核级条件变量即是condvar_t，其中包含一个信号量sem，一个等待计数器，和一个monitor指针，而monitor中有2个信号量mutex和next
(mutex用于对monitor加锁，next用于协调wait proc和signal proc)，一个计数器和一个条件变量指针。
相关操作有monitor_init、cond_signal和cond_wait
monitor_init:初始化函数，mutex初始为1，即状态为无锁，next初始为0
cond_signal:检查等待计数器是否为正数确定是否有等待进程，如果有的话释放monitor的锁，并试图获取next锁
cond_wait:检测是否有等待被唤醒的进程，如果有的话唤醒它，否则释放monitor的锁，并试图获取条件变量的信号量
```

2-2 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
```
与信号量类似的，用户态没有办法关闭中断，可以使用系统调用的方法或原子操作设计条件变量机制
```

## [与参考答案的区别]
```
思路上没有太大区别，具体代码上略有区别。
```

## [实验中重要的知识点]
```
信号量
条件变量
哲学家就餐
```

